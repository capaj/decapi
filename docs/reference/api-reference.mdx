# Api Reference

## @ObjectType

Registers a class as a GraphQL object type.

```ts
interface ObjectTypeOptions {
  name?: string; // infered from class name
  description?: string;
}

@ObjectType(options?: ObjectTypeOptions)
```

## @Field

Registers a class field as a GraphQLField.

```ts
 interface FieldOptions {
  name?: string;
  description?: string;
  type?: any | () => any;
  isNullable?: boolean;
}

@Field(options?: FieldOptions)
```

## @InputObjectType

```ts
interface InputObjectTypeOptions {
  name?: string;
  description?: string;
}

@InputObjectType(options?: InputObjectTypeOptions)
```

## @InputField

```ts
 interface InputFieldOptions {
  description?: string;
  defaultValue?: any;
  type?: any | () => any;
  name?: string;
  isNullable?: boolean;
}

@InputField(options?: InputFieldOptions)
```

## @DuplexObjectType

Just a shorthand-it is the same as putting both `@InputObjectType` and `@ObjectType`

```ts
interface DuplexObjectTypeOptions {
  name?: string;
  description?: string;
}

@DuplexObjectType(options?: DuplexObjectTypeOptions)
```

## @DuplexField

Just a shorthand-it is the same as putting both `@InputField` and `@Field`

```ts
 interface DuplexFieldOptions {
  description?: string;
  defaultValue?: any;
  type?: any | () => any;
  name?: string;
  isNullable?: boolean;
  inputNullable?: boolean;
}

@DuplexField(options?: DuplexFieldOptions)
```

## @Arg

```ts
 interface ArgOptions {
  description?: string;
  type?: any;
  isNullable?: boolean;
}
@Arg(options?: ArgOptions)
```

## @Inject

```ts
type InjectorResolver = (
  source: any,
  args: any,
  context: any,
  info: GraphQLResolveInfo,
) => any;

@Inject(resolver: InjectorResolver): ParameterDecorator {
```

## @Context

No decorator options avaliable

```ts
@Context: ParameterDecorator
```

## @Source

No decorator options avaliable

```ts
@Source: ParameterDecorator
```

## @Info

No decorator options avaliable

```ts
@Info: ParameterDecorator
```

## @Before

```ts
interface HookExecutorResolverArgs {
  source: any;
  args: { [argName: string]: any };
  context: any;
  info: GraphQLResolveInfo;
}

type HookExecutor = (data: HookExecutorResolverArgs) => any | Promise<any>;

@Before(hook: HookExecutor);
```

## @After

```ts
interface HookExecutorResolverArgs {
  source: any;
  args: { [argName: string]: any };
  context: any;
  info: GraphQLResolveInfo;
}

type HookExecutor = (data: HookExecutorResolverArgs) => any | Promise<any>;

@After(hook: HookExecutor);
```

## @Schema

```ts
@Schema(): ClassDecorator;
```

## @Query

Has same interface as [@Field](#field) decorator. Can be used only inside @Schema class

## @Mutation

Has same interface as [@Field](#field) decorator. Can be used only inside @Schema class

## @Union

```ts
interface UnionOptions {
  name?: string;
  resolveTypes?: (value: any, context: any, info: GraphQLResolveInfo): any; // must return type resolvable to one of defined in `types` option
  types: any[] | () => any[];
}

interface UnionTypeResolver {
  (value: any, context: any, info: GraphQLResolveInfo): any;
}

@Union(options: UnionOptions): ClassDecorator;
```

## registerEnum

```ts
interface EnumOptions {
  name: string;
  description?: string;
}

registerEnum(enumDef: Object, options: EnumOptions | string): void;
```

## compileSchema

```ts
compileSchema(schemaTarget: Function): GraphQLSchema
```

## compileObjectType,

```ts
compileObjectType(schemaTarget: Function): GraphQLObjectType
```

## compileInputObjectType,

```ts
compileInputObjectType(schemaTarget: Function): GraphQLInputObjectType
```
