# Mixins

mixins which can be easily "sprinkled" onto any class in your existing hierarchy.
At runtime method fields on the mixin run in the context of a class where you apply them, but
typescript doesn't know that, so you have to explicitly set `this` parameter, as shown:

```ts
import { ObjectType, Field, Union } from 'decapi'

interface IHasMyProp {
  myProp: number
}

@ObjectType()
class Mixin {
  @Field()
  printMyProp(
    this: IHasMyProp, // <-- you need to explicitly set an interface which all classes implement for this mixin
    a: string
  ): string {
    return `my prop is ${this.myProp}`
  }
}

@ObjectType({ mixins: [Mixin] })
class Hello implements IHasMyProp {
  myProp = 5
  @Field()
  world(name: string): string {
    return `Hello, ${name}`
  }
}
```

**NOTE: same as when defining a `type`, you can define a `mixin` prop value as a thunk to be safe from circular dependencies:**

```ts
@ObjectType({ mixins: () => [Mixin] })
```
