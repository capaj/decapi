(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{"./docs/explore/schema/Schema.mdx":function(e,n,a){"use strict";a.r(n);var t=a("./node_modules/react/index.js"),m=a.n(t),o=a("./node_modules/@mdx-js/tag/dist/index.js");function r(e,n){if(null==e)return{};var a,t,m=function(e,n){if(null==e)return{};var a,t,m={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(m[a]=e[a]);return m}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(m[a]=e[a])}return m}n.default=function(e){var n=e.components;r(e,["components"]);return m.a.createElement(o.MDXTag,{name:"wrapper",components:n},m.a.createElement(o.MDXTag,{name:"h1",components:n,props:{id:"schema"}},"Schema"),m.a.createElement(o.MDXTag,{name:"h3",components:n,props:{id:"what-is-decapi"}},"What is ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"h3"},"decapi"),"?"),m.a.createElement(o.MDXTag,{name:"p",components:n},"decapi is set of decorators allowing creating GraphQL APIs quickly and in type-safe way."),m.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"creating-very-simple-schema"}},"Creating very simple schema"),m.a.createElement(o.MDXTag,{name:"p",components:n},"Schema is main building block of any ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"graphql")," schema. It'll join all parts of our api together."),m.a.createElement(o.MDXTag,{name:"p",components:n},"In ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"decapi")," to create schema, we need to pass class decorated with ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"@Schema")," to ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"compileSchema")," function"),m.a.createElement(o.MDXTag,{name:"pre",components:n},m.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"import { Schema, compileSchema} from 'decapi\n\n@Schema()\nclass SuperSchema {\n  // fields implementation\n}\n\nconst compiledSchema = compileSchema(SuperSchema);\n")),m.a.createElement(o.MDXTag,{name:"p",components:n},m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"compiledSchema")," from example above is standard, regular ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"graphql")," schema."),m.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"adding-query-and-mutation-fields"}},"Adding Query and Mutation fields"),m.a.createElement(o.MDXTag,{name:"p",components:n},"Any working schema requires at least one Query field. There are special decorators - ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"@Query")," and ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"@Mutation")," used to register root fields of schema."),m.a.createElement(o.MDXTag,{name:"p",components:n},"Very simple fully working schema like"),m.a.createElement(o.MDXTag,{name:"pre",components:n},m.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-graphql"}},"{\n  hello # will resolve to 'world'\n}\n")),m.a.createElement(o.MDXTag,{name:"p",components:n},"Could be implemented as:"),m.a.createElement(o.MDXTag,{name:"pre",components:n},m.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"import { Schema, Query, compileSchema} from 'decapi\n\n@Schema()\nclass SuperSchema {\n  @Query()\n  hello(): string {\n    return 'world'\n  }\n}\n\nconst compiledSchema = compileSchema(SuperSchema);\n")),m.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"adding-parameters"}},"Adding parameters"),m.a.createElement(o.MDXTag,{name:"p",components:n},"Let's add some customization to our schema:"),m.a.createElement(o.MDXTag,{name:"pre",components:n},m.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-graphql"}},"{\n  hello(name: \"Bob\") # will resolve to 'Hello, Bob!'\n}\n")),m.a.createElement(o.MDXTag,{name:"p",components:n},"With tiny change in our code:"),m.a.createElement(o.MDXTag,{name:"pre",components:n},m.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"import { Schema, Query, compileSchema} from 'decapi\n\n@Schema()\nclass SuperSchema {\n  @Query()\n  hello(name: string): string {\n    return `Hello, ${name}!`;\n  }\n}\n\nconst compiledSchema = compileSchema(SuperSchema);\n")),m.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"adding-nested-types"}},"Adding nested types"),m.a.createElement(o.MDXTag,{name:"p",components:n},"For now, our query field returned scalar (string). Let's return something more complex. Schema will look like:"),m.a.createElement(o.MDXTag,{name:"pre",components:n},m.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-graphql"}},'mutation {\n  createProduct(name: "Chair", price: 99.99) {\n    name\n    price\n    isExpensive\n  }\n}\n')),m.a.createElement(o.MDXTag,{name:"p",components:n},"Such query will have a bit more code and here it is:"),m.a.createElement(o.MDXTag,{name:"pre",components:n},m.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"import { Schema, Query, ObjectType, Field, Mutation, compileSchema} from 'decapi;\n\n@ObjectType({ description: 'Simple product object type' })\nclass Product {\n  @Field()\n  name: string;\n\n  @Field()\n  price: number;\n\n  @Field()\n  isExpensive() {\n    return this.price > 50;\n  }\n}\n\n@Schema()\nclass SuperSchema {\n  @Mutation()\n  createProduct(name: string, price: number): Product {\n    const product = new Product();\n    product.name = name;\n    product.price = price;\n    return product;\n  }\n}\n\nconst compiledSchema = compileSchema(SuperSchema);\n")),m.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"forcing-field-type"}},"Forcing field type."),m.a.createElement(o.MDXTag,{name:"p",components:n},"Since now, ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"decapi")," was able to guess type of every field from typescript type definitions."),m.a.createElement(o.MDXTag,{name:"p",components:n},"There are, however, some cases where we'd have to define them explicitly."),m.a.createElement(o.MDXTag,{name:"ul",components:n},m.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"We want to strictly tell if field is nullable or not"),m.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Function we use returns type of ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"Promise<SomeType>")," while field itself is typed as ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"SomeType")),m.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"List (Array) type is used. (For now, typescript ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"Reflect")," api is not able to guess type of single array item. This might change in the future)")),m.a.createElement(o.MDXTag,{name:"p",components:n},"Let's modify our ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Product")," so it has additional ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"categories")," field that will return array of strings. For sake of readibility, I'll ommit all fields we've defined previously."),m.a.createElement(o.MDXTag,{name:"pre",components:n},m.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"@ObjectType()\nclass Product {\n  @Field({ type: [String] }) // note we can use any native type like GraphQLString!\n  categories(): string[] {\n    return ['Tables', 'Furniture']\n  }\n}\n")),m.a.createElement(o.MDXTag,{name:"p",components:n},"We've added ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"{ type: [String] }")," as ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"@Field")," options. Type can be anything that is resolvable to ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"GraphQL")," type"),m.a.createElement(o.MDXTag,{name:"ul",components:n},m.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Native JS scalars: ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"String"),", ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"Number"),", ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"Boolean"),"."),m.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Any type that is already compiled to ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"graphql")," eg. ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"GraphQLFloat")," or any type from external graphql library etc"),m.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Every class decorated with ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"@ObjectType")),m.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"One element array of any of above for list types eg. ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"[String]")," or ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"[GraphQLFloat]"))),m.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"writing-asynchroniously"}},"Writing Asynchroniously"),m.a.createElement(o.MDXTag,{name:"p",components:n},"Every field function we write can be ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"async")," and return ",m.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Promise"),". Let's say, instead of hard-coding our categories, we want to fetch it from some external API:"),m.a.createElement(o.MDXTag,{name:"pre",components:n},m.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"@ObjectType()\nclass Product {\n  @Field({ type: [String] }) // note we can use any native type like GraphQLString!\n  async categories(): Promise<string[]> {\n    const categories = await api.fetchCategories()\n    return categories.map((cat) => cat.name)\n  }\n}\n")))}}}]);