(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{"./docs/explore/mixins.mdx":function(e,n,t){"use strict";t.r(n);var r=t("./node_modules/react/index.js"),a=t.n(r),o=t("./node_modules/@mdx-js/tag/dist/index.js");function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}n.default=function(e){var n=e.components;i(e,["components"]);return a.a.createElement(o.MDXTag,{name:"wrapper",components:n},a.a.createElement(o.MDXTag,{name:"h1",components:n,props:{id:"mixins"}},"Mixins"),a.a.createElement(o.MDXTag,{name:"p",components:n},'When a regular class inheritance is not flexible enough, you can create mixins which can be easily "sprinkled" onto any class in your existing hierarchy. At runtime method fields on the mixin run in the context of a class where you apply them, but typescript doesn\'t know that, so you have to explicitly set ',a.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"this")," parameter, as shown:"),a.a.createElement(o.MDXTag,{name:"pre",components:n},a.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"import { ObjectType, Field, Union } from 'decapi'\n\ninterface IHasMyProp {\n  myProp: number\n}\n\n@ObjectType()\nclass Mixin {\n  @Field()\n  printMyProp(\n    this: IHasMyProp, // <-- you need to explicitly set an interface which all classes implement for this mixin\n    a: string,\n  ): string {\n    return `my prop is ${this.myProp}`\n  }\n}\n\n@ObjectType({ mixins: [Mixin] })\nclass Hello implements IHasMyProp {\n  myProp = 5\n  @Field()\n  world(name: string): string {\n    return `Hello, ${name}`\n  }\n}\n")))}}}]);