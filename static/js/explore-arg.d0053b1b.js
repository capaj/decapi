(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{"./docs/explore/arg.mdx":function(e,n,a){"use strict";a.r(n);var t=a("./node_modules/react/index.js"),o=a.n(t),r=a("./node_modules/@mdx-js/tag/dist/index.js");function m(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}n.default=function(e){var n=e.components;m(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h1",components:n,props:{id:"field-arguments"}},"Field arguments"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Many of fields in graphql queries use arguments. eg"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-graphql"}},"query {\n  calculator {\n    add(a: 2, b: 3)\n  }\n}\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Let's create such ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Calculator")," object type."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"import { ObjectType, Field } from 'decapi'\n\n@ObjectType()\nclass Calculator {\n  @Field()\n  add(a: number, b: number): number {\n    return a + b\n  }\n}\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Note we didn't even have to use ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"@Arg")," decorator yet. In case of simple, scalar argument types like ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"string"),", ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"number"),", ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"boolean")," it's not required. By default arguments not decorated with ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"@Arg")," are ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"required"),"."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"customizing-argumens-eg-adding-default-value"}},"Customizing argumens (eg. adding default value)"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Let's say we're building another calculator metod, called ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"pow")," which returns ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"base")," to the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"exponent")," power (base^exponent). By default, we want ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"exponent")," to be ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"2"),"."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"import { ObjectType, Field, Arg } from 'decapi'\n\n@ObjectType()\nclass Calculator {\n  @Field()\n  pow(\n    base: number,\n    @Arg({ nullable: true, defaultValue: 2 }) exponent: number,\n  ): number {\n    return Math.pow(base, exponent)\n  }\n}\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Right now ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"exponent")," argument is optional so we can use both:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-graphql"}},"fragment A on Calculator {\n  pow(2) # 4\n}\n\nfragment B on Calculator {\n  pow(2, 5) # 32\n}\n")))}}}]);