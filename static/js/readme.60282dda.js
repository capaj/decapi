(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{"./docs/README.mdx":function(e,n,a){"use strict";a.r(n);var t=a("./node_modules/react/index.js"),o=a.n(t),m=a("./node_modules/@mdx-js/tag/dist/index.js");function r(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},m=Object.keys(e);for(t=0;t<m.length;t++)a=m[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var m=Object.getOwnPropertySymbols(e);for(t=0;t<m.length;t++)a=m[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}n.default=function(e){var n=e.components;r(e,["components"]);return o.a.createElement(m.MDXTag,{name:"wrapper",components:n},o.a.createElement(m.MDXTag,{name:"h1",components:n,props:{id:"getting-started"}},"Getting started"),o.a.createElement(m.MDXTag,{name:"h3",components:n,props:{id:"what-is-decapi"}},"What is ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"h3"},"decapi"),"?"),o.a.createElement(m.MDXTag,{name:"p",components:n},"decapi is set of decorators allowing creating GraphQL APIs quickly and in type-safe way."),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"creating-very-simple-schema"}},"Creating very simple schema"),o.a.createElement(m.MDXTag,{name:"p",components:n},"Schema is main building block of any ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"graphql")," schema. It'll join all parts of our api together."),o.a.createElement(m.MDXTag,{name:"p",components:n},"In ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"decapi")," to create schema, we need to pass class decorated with ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"@Schema")," to ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"compileSchema")," function"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"import { Schema, compileSchema} from 'decapi\n\n@Schema()\nclass SuperSchema {\n  // fields implementation\n}\n\nconst compiledSchema = compileSchema(SuperSchema);\n")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"compiledSchema")," from example above is standard, regular ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"graphql")," schema."),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"adding-query-and-mutation-fields"}},"Adding Query and Mutation fields"),o.a.createElement(m.MDXTag,{name:"p",components:n},"Any working schema requires at least one Query field. There are special decorators - ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"@Query")," and ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"@Mutation")," used to register root fields of schema."),o.a.createElement(m.MDXTag,{name:"p",components:n},"Very simple fully working schema like"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-graphql"}},"{\n  hello # will resolve to 'world'\n}\n")),o.a.createElement(m.MDXTag,{name:"p",components:n},"Could be implemented as:"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"import { Schema, Query, compileSchema} from 'decapi\n\n@Schema()\nclass SuperSchema {\n  @Query()\n  hello(): string {\n    return 'world'\n  }\n}\n\nconst compiledSchema = compileSchema(SuperSchema);\n")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"adding-parameters"}},"Adding parameters"),o.a.createElement(m.MDXTag,{name:"p",components:n},"Let's add some customization to our schema:"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-graphql"}},"{\n  hello(name: \"Bob\") # will resolve to 'Hello, Bob!'\n}\n")),o.a.createElement(m.MDXTag,{name:"p",components:n},"With tiny change in our code:"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"import { Schema, Query, compileSchema} from 'decapi\n\n@Schema()\nclass SuperSchema {\n  @Query()\n  hello(name: string): string {\n    return `Hello, ${name}!`;\n  }\n}\n\nconst compiledSchema = compileSchema(SuperSchema);\n")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"adding-nested-types"}},"Adding nested types"),o.a.createElement(m.MDXTag,{name:"p",components:n},"For now, our query field returned scalar (string). Let's return something more complex. Schema will look like:"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-graphql"}},'mutation {\n  createProduct(name: "Chair", price: 99.99) {\n    name\n    price\n    isExpensive\n  }\n}\n')),o.a.createElement(m.MDXTag,{name:"p",components:n},"Such query will have a bit more code and here it is:"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"import { Schema, Query, ObjectType, Field, Mutation, compileSchema} from 'decapi;\n\n@ObjectType({ description: 'Simple product object type' })\nclass Product {\n  @Field()\n  name: string;\n\n  @Field()\n  price: number;\n\n  @Field()\n  isExpensive() {\n    return this.price > 50;\n  }\n}\n\n@Schema()\nclass SuperSchema {\n  @Mutation()\n  createProduct(name: string, price: number): Product {\n    const product = new Product();\n    product.name = name;\n    product.price = price;\n    return product;\n  }\n}\n\nconst compiledSchema = compileSchema(SuperSchema);\n")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"forcing-field-type"}},"Forcing field type."),o.a.createElement(m.MDXTag,{name:"p",components:n},"Since now, ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"decapi")," was able to guess type of every field from typescript type definitions."),o.a.createElement(m.MDXTag,{name:"p",components:n},"There are, however, some cases where we'd have to define them explicitly."),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"We want to strictly tell if field is nullable or not"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Function we use returns type of ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"Promise<SomeType>")," while field itself is typed as ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"SomeType")),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"List (Array) type is used. (For now, typescript ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"Reflect")," api is not able to guess type of single array item. This might change in the future)")),o.a.createElement(m.MDXTag,{name:"p",components:n},"Let's modify our ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Product")," so it has additional ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"categories")," field that will return array of strings. For sake of readibility, I'll ommit all fields we've defined previously."),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"@ObjectType()\nclass Product {\n  @Field({ type: [String] }) // note we can use any native type like GraphQLString!\n  categories(): string[] {\n    return ['Tables', 'Furniture']\n  }\n}\n")),o.a.createElement(m.MDXTag,{name:"p",components:n},"We've added ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"{ type: [String] }")," as ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"@Field")," options. Type can be anything that is resolvable to ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"GraphQL")," type"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Native JS scalars: ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"String"),", ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"Number"),", ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"Boolean"),"."),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Any type that is already compiled to ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"graphql")," eg. ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"GraphQLFloat")," or any type from external graphql library etc"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Every class decorated with ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"@ObjectType")),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"One element array of any of above for list types eg. ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"[String]")," or ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"[GraphQLFloat]"))),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"writing-asynchroniously"}},"Writing Asynchroniously"),o.a.createElement(m.MDXTag,{name:"p",components:n},"Every field function we write can be ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"async")," and return ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Promise"),". Let's say, instead of hard-coding our categories, we want to fetch it from some external API:"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"@ObjectType()\nclass Product {\n  @Field({ type: [String] }) // note we can use any native type like GraphQLString!\n  async categories(): Promise<string[]> {\n    const categories = await api.fetchCategories()\n    return categories.map((cat) => cat.name)\n  }\n}\n")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"adding-to-your-project"}},"Adding to your project"),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"getting-started-setup"}},"Installation and setup")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Important!")," setup steps are simple, but required. Make sure to check ",o.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"getting-started-setup"}},"setup")," section."))}}}]);